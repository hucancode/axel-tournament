// Security tests to verify sandbox isolation against malicious code
// These tests compile malicious programs and run them in the sandbox to verify they are blocked
use nix::sys::signal::{Signal, kill};
use nix::sys::wait::{WaitStatus, waitpid};
use std::fs;
use std::io::Read;
use std::os::unix::io::FromRawFd;
use std::path::Path;
use std::time::Duration;
use tempfile::TempDir;

#[cfg(test)]
mod cgroup_tests {
    use judge::services::sandbox::cgroup::CgroupHandle;
    use nix::unistd::Pid;

    #[test]
    fn test_cgroup_creation() {
        let result = CgroupHandle::new_compilation("test_submission_123");
        assert!(result.is_ok(), "cgroup creation should be success");
        let result = CgroupHandle::new_execution("test_player_456");
        assert!(result.is_ok(), "cgroup creation should be success");
    }

    #[test]
    fn test_cgroup_unique_names() {
        // Test that creating multiple cgroups with different names works
        let result1 = CgroupHandle::new_compilation("submission_1");
        let result2 = CgroupHandle::new_compilation("submission_2");
        // Both should succeed or both should fail
        assert_eq!(
            result1.is_ok(),
            result2.is_ok(),
            "Cgroup creation consistency check"
        );
    }

    #[test]
    fn test_cgroup_add_task_to_nonexistent_pid() {
        if let Ok(handle) = CgroupHandle::new_execution("test_invalid_pid") {
            // Try to add an invalid PID
            let invalid_pid = Pid::from_raw(999999);
            let result = handle.add_task(invalid_pid);
            // Should fail gracefully
            assert!(result.is_err(), "Adding invalid PID should fail");
        }
    }
}

#[cfg(test)]
mod sandbox_execution_tests {
    use super::*;
    use judge::services::sandbox::compiler::CompilerSandbox;
    use judge::services::sandbox::executor;

    /// Helper to run a compiled binary and get its output
    fn run_sandboxed_and_capture(
        player_id: &str,
        binary_path: &Path,
        timeout_secs: u64,
    ) -> Result<(String, i32), String> {
        // Spawn the sandboxed process
        let process = executor::spawn_sandboxed(player_id, binary_path)
            .map_err(|e| format!("Failed to spawn: {}", e))?;

        // Close stdin (we don't need to send input)
        unsafe {
            nix::libc::close(process.stdin_fd);
        }

        let stdout_fd = process.stdout_fd;
        let pid = process.pid;

        // Read stdout in a separate thread
        let output_handle = std::thread::spawn(move || {
            let mut output = String::new();
            unsafe {
                let mut file = std::fs::File::from_raw_fd(stdout_fd);
                // Set a timeout on the file descriptor
                let _ = file.read_to_string(&mut output);
            }
            output
        });

        // Wait for process with timeout
        std::thread::sleep(Duration::from_secs(timeout_secs));

        // Try to get exit status
        let exit_code = match waitpid(pid, Some(nix::sys::wait::WaitPidFlag::WNOHANG)) {
            Ok(WaitStatus::Exited(_, code)) => code,
            Ok(WaitStatus::Signaled(_, sig, _)) => {
                eprintln!("Process killed by signal: {:?}", sig);
                128 + (sig as i32)
            }
            _ => {
                // Process still running, kill it
                eprintln!("Process still running after timeout, killing...");
                let _ = kill(pid, Signal::SIGKILL);
                let _ = waitpid(pid, None);
                -1
            }
        };

        // Get output (may timeout if process is stuck)
        let output = match output_handle.join() {
            Ok(out) => out,
            Err(_) => String::from("[Failed to capture output]"),
        };

        Ok((output, exit_code))
    }

    #[tokio::test]
    async fn test_read_passwd_is_blocked() {
        let temp_dir = TempDir::new().unwrap();
        let sandbox = CompilerSandbox::new(temp_dir.path().to_path_buf()).unwrap();

        let source = fs::read_to_string("tests/malicious/read_passwd.c")
            .expect("Should be able to read test file");

        let binary = sandbox
            .compile("read_passwd_test", "c", &source)
            .await
            .expect("Compilation should succeed");

        println!("Running malicious program: {}", binary);

        match run_sandboxed_and_capture("read_passwd_test", Path::new(&binary), 3) {
            Ok((output, exit_code)) => {
                println!("=== Output ===\n{}", output);
                println!("Exit code: {}", exit_code);

                // Success criteria: either blocked or non-zero exit
                assert!(
                    output.contains("BLOCKED") || exit_code != 0,
                    "Program should be blocked from reading /etc/passwd"
                );

                assert!(
                    !output.contains("SECURITY BREACH"),
                    "No security breach should occur"
                );
            }
            Err(e) => {
                println!("Execution failed: {}", e);
                // This might be expected in some test environments
            }
        }
    }

    #[tokio::test]
    async fn test_read_shadow_is_blocked() {
        let temp_dir = TempDir::new().unwrap();
        let sandbox = CompilerSandbox::new(temp_dir.path().to_path_buf()).unwrap();

        let source = fs::read_to_string("tests/malicious/read_shadow.c")
            .expect("Should be able to read test file");

        let binary = sandbox
            .compile("read_shadow_test", "c", &source)
            .await
            .expect("Compilation should succeed");

        match run_sandboxed_and_capture("read_shadow_test", Path::new(&binary), 3) {
            Ok((output, exit_code)) => {
                println!("=== Output ===\n{}", output);
                println!("Exit code: {}", exit_code);

                assert!(
                    output.contains("BLOCKED") || exit_code != 0,
                    "Program should be blocked from reading /etc/shadow"
                );

                assert!(
                    !output.contains("SECURITY BREACH"),
                    "No security breach should occur"
                );
            }
            Err(e) => println!("Execution failed: {}", e),
        }
    }

    #[tokio::test]
    async fn test_list_home_is_blocked() {
        let temp_dir = TempDir::new().unwrap();
        let sandbox = CompilerSandbox::new(temp_dir.path().to_path_buf()).unwrap();

        let source = fs::read_to_string("tests/malicious/list_home.c")
            .expect("Should be able to read test file");

        let binary = sandbox
            .compile("list_home_test", "c", &source)
            .await
            .expect("Compilation should succeed");

        match run_sandboxed_and_capture("list_home_test", Path::new(&binary), 3) {
            Ok((output, exit_code)) => {
                println!("=== Output ===\n{}", output);
                println!("Exit code: {}", exit_code);

                assert!(
                    output.contains("BLOCKED") || exit_code != 0,
                    "Program should be blocked from listing /home"
                );

                assert!(
                    !output.contains("SECURITY BREACH"),
                    "No security breach should occur"
                );
            }
            Err(e) => println!("Execution failed: {}", e),
        }
    }

    #[tokio::test]
    async fn test_path_traversal_is_blocked() {
        let temp_dir = TempDir::new().unwrap();
        let sandbox = CompilerSandbox::new(temp_dir.path().to_path_buf()).unwrap();

        let source = fs::read_to_string("tests/malicious/path_traversal.c")
            .expect("Should be able to read test file");

        let binary = sandbox
            .compile("path_traversal_test", "c", &source)
            .await
            .expect("Compilation should succeed");

        match run_sandboxed_and_capture("path_traversal_test", Path::new(&binary), 3) {
            Ok((output, exit_code)) => {
                println!("=== Output ===\n{}", output);
                println!("Exit code: {}", exit_code);

                assert!(
                    output.contains("BLOCKED") || exit_code != 0,
                    "Path traversal should be blocked"
                );

                assert!(
                    !output.contains("SECURITY BREACH"),
                    "No security breach should occur"
                );
            }
            Err(e) => println!("Execution failed: {}", e),
        }
    }

    #[tokio::test]
    async fn test_write_tmp_is_blocked() {
        let temp_dir = TempDir::new().unwrap();
        let sandbox = CompilerSandbox::new(temp_dir.path().to_path_buf()).unwrap();

        let source = fs::read_to_string("tests/malicious/write_tmp.c")
            .expect("Should be able to read test file");

        let binary = sandbox
            .compile("write_tmp_test", "c", &source)
            .await
            .expect("Compilation should succeed");

        match run_sandboxed_and_capture("write_tmp_test", Path::new(&binary), 3) {
            Ok((output, exit_code)) => {
                println!("=== Output ===\n{}", output);
                println!("Exit code: {}", exit_code);

                assert!(
                    output.contains("BLOCKED") || exit_code != 0,
                    "Writing to /tmp should be blocked"
                );

                assert!(
                    !output.contains("SECURITY BREACH"),
                    "No security breach should occur"
                );

                // Verify file wasn't created on host
                assert!(
                    !Path::new("/tmp/malicious_file").exists(),
                    "File should not exist on host filesystem"
                );
            }
            Err(e) => println!("Execution failed: {}", e),
        }
    }

    #[tokio::test]
    async fn test_all_malicious_programs_blocked() {
        let temp_dir = TempDir::new().unwrap();
        let sandbox = CompilerSandbox::new(temp_dir.path().to_path_buf()).unwrap();

        let programs = vec![
            ("read_passwd", include_str!("malicious/read_passwd.c")),
            ("read_shadow", include_str!("malicious/read_shadow.c")),
            ("list_home", include_str!("malicious/list_home.c")),
            ("read_proc", include_str!("malicious/read_proc_self.c")),
            ("path_traversal", include_str!("malicious/path_traversal.c")),
            ("write_tmp", include_str!("malicious/write_tmp.c")),
        ];
        let mut breach_count = 0;
        for (name, source) in programs {
            println!("\n=== Testing: {} ===", name);
            let binary = match sandbox.compile(name, "c", source).await {
                Ok(b) => b,
                Err(e) => {
                    println!("Compilation failed: {}", e);
                    continue;
                }
            };
            match run_sandboxed_and_capture(name, Path::new(&binary), 3) {
                Ok((output, exit_code)) => {
                    println!("Output:\n{}", output);
                    println!("Exit code: {}", exit_code);
                    if exit_code != 0 {
                        println!("Successfully blocked");
                    } else {
                        breach_count += 1;
                        eprintln!("SECURITY BREACH!");
                    }
                }
                Err(e) => {
                    panic!("Execution error: {}", e);
                }
            }
        }
        assert_eq!(breach_count, 0, "No security breaches should occur");
    }
}
